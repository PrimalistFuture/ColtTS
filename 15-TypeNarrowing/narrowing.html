<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Type Narrowing</title>
</head>

<body>
    <h1>Type Narrowing</h1>

    <p>Refers to the pattern in TypeScript in which you have a function that could take an input of multiple types, and
        you have to perform some logic to it in order to handle those different types properly.
    </p>


    <h2>typeof</h2>
    <p><b>typeof</b> Type Guards involve simply doing a type check before working with a value. Since unions allow
        multiple types for a value, we can first check what came through before working with it.
    </p>

    <p>This isn't a TypeScript specific pattern, obviously we might have to check the type in normal JS. But happens a
        lot because of the additional guards TS puts on us.</p>

    <h2>Truthiness Guard</h2>

    <p><b>Truthiness</b> Type Guards involve checking a value for being truthy or falsy before working with it. Very
        helpful in avoiding erros when values might be null or undefined.
    </p>

    <h2>Equality Narrowing</h2>

    <p><b>Equality</b> Type Guards involve comparing types to each other before doing certain operations with values. By
        checking two values against one another, we can be sure they're both the same before working with them in a
        type-specific way.
    </p>

    <h2>In Operator</h2>

    <p>JavaScripts <b>in</b> operator helps check if a certain property exists in an object. This means we can use it to
        check if a value exists in an object, according to its type alias or aliases, before working with it.
    </p>

    <h2>instanceof Narrowing</h2>

    <p><b>instanceof</b> is a JavaScript operator that allows us to check if one thing is an instance of another, such as prototypes and classes or anything else made with the <b>new</b> keyword. This can help us narrow types when working with classes.</p>

    <h2>Type Predicates</h2>

    <p>TypeScript allows us to write custom functions that can narrow the type of a value. These function have a very special return type called a <b>type predicate</b>. A predicate takes the form <b>parameterName is Type</b>.</p>

    <p>Usually these functions are usually phrased like a boolean. isCat isUser and so on. These functions are meant to be reusuable.</p>

    <p>Mostly this just seems like a way of placating TypeScript so it doesn't get mad at you.</p>

    <h2>Discriminated Unions</h2>

    <p>A common pattern in TS that involves creating a literal property that is common across multiple types. We can then narrow the type using that literal property.</p>

    <p>Commonly, this property is called kind or type or __type or TYPE or something similar. It doesn't really matter as long as you are consistent within your interfaces.</p>

    <h2>Exhaustiveness Checking with Never</h2>

    <p>This makes use of the <b>never type</b> which itself is assignable to every other type, but no other type is assignable to never. CTD included in the discrimated Unions section.</p>


















</body>

</html>