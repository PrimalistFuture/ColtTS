<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Union Types</title>
</head>

<body>
    <h1>Union Types</h1>

    <p><b>Union Types</b> allow us to give a value a few different possible types. IF the eventual type is included,
        TypeScript will be happy. We can create a union type by using the <b>single | (pipe) character</b> to seperate
        the
        types we want to include. TS will enforce it from there.
    </p>

    <h2>Union Types with Functions</h2>

    <p>Things can get strange if your function tries to do something to a parameter that can be one of a union of
        several types. To get around this, we can use <b>Type Narrowing</b>, which is some conditional logic to handle
        the different types that our union expects. Can be done many different ways, but typeof === 'string' or whatever
        is very common.
    </p>

    <h2>Union Types with Arrays</h2>

    <p>Can be applied to arrays as well. Place () around the types, <b>variable: (type | type)[] = [stuff]</b></p>

    <h2>Union Types and Literal Types</h2>

    <p>Literal Types are not just types, they are the values themselves. On their own, that's not super helpful. But
        they can be combined with unions to achieve very fine-tuned type options for TypeScript to enforce. CTD.
    </p>








</body>

</html>